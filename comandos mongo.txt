mongosh // para iniciar conexion
cls // limpiar consola
exit // salir

show dbs // mostrar databases
db.dropDatabase("usuarios") // eliminar database

use usuarios // para crear database
show collections  // mostrar colecciones

db.createCollection("usuario")  // crear colección

// crear elemento con arrays y date
db.usuario.insertOne({
    "_id": ObjectId("123456789012"),
    "nombre": "Juan Pérez",
    "edad": 30,
    "correo": "juan@example.com",
    "ciudad": "Ciudad de México",
    "intereses": ["fútbol", "viajar", "lectura"],
    "amigos": [
      {"nombre": "María García", "edad": 28},
      {"nombre": "Carlos López", "edad": 32}
    ],
    "historial_compras": [
      {"producto": "Laptop", "precio": 1200},
      {"producto": "Teléfono", "precio": 800},
      {"producto": "Libro", "precio": 20}
    ],
    "ultima_conexion": ISODate("2024-04-27T18:30:00Z"),
    "activo": true
  }) 
// si no esta la colección la crea


db.usuario.find() //ver elementos
db.getCollection("usuario").find()


// insertar varios
db.usuario.insertMany([
  {
    "_id": ObjectId("123456789013"),
    "nombre": "María García",
    "edad": 28,
    "correo": "maria@example.com",
    "ciudad": "Guadalajara",
    "intereses": ["pintura", "bailar", "senderismo"],
    "amigos": [
      {"nombre": "Juan Pérez", "edad": 30},
      {"nombre": "Luisa Martínez", "edad": 27}
    ],
    "historial_compras": [
      {"producto": "Cámara", "precio": 500},
      {"producto": "Botas de montaña", "precio": 120},
      {"producto": "Esmalte de uñas", "precio": 10}
    ],
    "ultima_conexion": ISODate("2024-04-26T12:45:00Z"),
    "activo": true
  },
  {
    "_id": ObjectId("123456789014"),
    "nombre": "Carlos López",
    "edad": 32,
    "correo": "carlos@example.com",
    "ciudad": "Monterrey",
    "intereses": ["cocina", "música", "tecnología"],
    "amigos": [
      {"nombre": "Juan Pérez", "edad": 30},
      {"nombre": "Luisa Martínez", "edad": 27}
    ],
    "historial_compras": [
      {"producto": "Teclado", "precio": 80},
      {"producto": "Audífonos", "precio": 50},
      {"producto": "Ingrediente X", "precio": 5}
    ],
    "ultima_conexion": ISODate("2024-04-25T09:15:00Z"),
    "activo": false
  }
])
//insertar varios




//insertar desde mongo compass
[{
  name: "fernando", age: 45, points: 7.1},
  {name: "pablo", age: 21, points: 7.0}
]


// otro ejemplo de insercción con estructura compleja y nulos
db.students.insertOne({
  name: "chema", 
  age: 23,
  tipo: true, 
  date: new Date("2020-02-01T00:00:00"), 
  graduacion: null, 
  courses:["uno","dos"],
  direccion:{
    calle:"bodeguilla",
    ciudad:"valladolid",
    zip:83838}
    }
  )


// find ordenando
// asc: primero a último z
db.usuario.find().sort({nombre:1}) 
// desc: primero z último a
db.usuario.find().sort({nombre:-1})  
// menos a más
db.usuario.find().sort({edad:1}) 
// más a menos
db.usuario.find().sort({edad:-1})  

// por fecha de creación, más recientes primero
db.usuario.find().sort({_id: -1}) 

// el de más edad, limitando resultados
db.usuario.find().sort({edad:-1}).limit(1)  

//compass
{name:1} y poner limit 1

// find con dos condiciones
db.usuario.find({edad:30, ciudad: "Ciudad de México"})  

// campos a mostrar, solo nombre
db.usuario.find({},{nombre: true})  
// sin id, solo nombre y edad
db.usuario.find({},{_id: false,nombre: true,edad:true}) 

//compass
{_id: false,nombre:true,edad:true}


//actualizar elemento con un criterio y el campo a modificar
db.usuario.updateOne({
  nombre:"Carlos López",
  edad:32},
  {$set: {ciudad:"Rio Janeiro"}}
)  


// actualizar por el id
db.usuario.updateOne({
  _id:ObjectId("313233343536373839303134")},
  {$set: {nombre:"Javier Martínez"}})


// eliminar campo actualizando
db.usuario.updateOne({
  _id:ObjectId("313233343536373839303134")},
  {$unset: {edad:""}})  

// crear campo actualizando
db.usuario.updateOne({
  _id:ObjectId("313233343536373839303134")},
  {$set: {edad:32}}) 


// actualizar varios, todos los mayores de 25 se les pone atributo
db.usuario.updateMany({
  edad:{$gt:25}},
  {$set: {mayores25:true}})  


// los que tienen el atributo mayores25 se le pone atributo, actualizar si tienen atributo
db.usuario.updateMany({
  mayores25: {$exists:true}},
  {$set: {clienteHabitual:true}}) 





//eliminar uno por condición
db.usuario.deleteOne({nombre:"Javier Martínez"}) 
// eliminar varios
db.usuario.deleteMany({mayores25: true}) 



//volvemos a insertar elementos como arriba


// todos los mayores de 30 se les pone atributo actualizando si cumplen condición
db.usuario.updateMany({
  edad:{$gt:30}},
  {$set: {mayores30:true}})  


// eliminar los que no tienen este campo
db.usuario.deleteMany({mayores30:{$exists:false}}) 


// eliminar por condición
db.usuario.deleteOne({nombre:"Carlos López"})


// volver a insertar como arriba pero sin ids
db.usuario.insertMany([
  {
    "nombre": "María García",
    "edad": 28,
    "correo": "maria@example.com",
    "ciudad": "Guadalajara",
    "intereses": ["pintura", "bailar", "senderismo"],
    "amigos": [
      {"nombre": "Juan Pérez", "edad": 30},
      {"nombre": "Luisa Martínez", "edad": 27}
    ],
    "historial_compras": [
      {"producto": "Cámara", "precio": 500},
      {"producto": "Botas de montaña", "precio": 120},
      {"producto": "Esmalte de uñas", "precio": 10}
    ],
    "ultima_conexion": ISODate("2024-04-26T12:45:00Z"),
    "activo": true
  },
  {
    "nombre": "Carlos López",
    "edad": 32,
    "correo": "carlos@example.com",
    "ciudad": "Monterrey",
    "intereses": ["cocina", "música", "tecnología"],
    "amigos": [
      {"nombre": "Juan Pérez", "edad": 30},
      {"nombre": "Luisa Martínez", "edad": 27}
    ],
    "historial_compras": [
      {"producto": "Teclado", "precio": 80},
      {"producto": "Audífonos", "precio": 50},
      {"producto": "Ingrediente X", "precio": 5}
    ],
    "ultima_conexion": ISODate("2024-04-25T09:15:00Z"),
    "activo": false
  },{
    "nombre": "Juan Pérez",
    "edad": 30,
    "correo": "juan@example.com",
    "ciudad": "Ciudad de México",
    "intereses": ["fútbol", "viajar", "lectura"],
    "amigos": [
      {"nombre": "María García", "edad": 28},
      {"nombre": "Carlos López", "edad": 32}
    ],
    "historial_compras": [
      {"producto": "Laptop", "precio": 1200},
      {"producto": "Teléfono", "precio": 800},
      {"producto": "Libro", "precio": 20}
    ],
    "ultima_conexion": ISODate("2024-04-27T18:30:00Z"),
    "activo": true
  }
])

// ordenar por fecha de creación, mostrar más recientes primero
db.usuario.find().sort({_id: -1}) 


//tambien se puede importar el json anterior en compass


// nombre que no sea María García
db.usuario.find({nombre:{$ne:"María García"}}) 
// menos de 30 de edad
db.usuario.find({edad:{$lt:30}}) 
// menos o igual
db.usuario.find({edad:{$lte:30}})  
// mayor que
db.usuario.find({edad:{$gt:30}}) 
// mayor o igual
db.usuario.find({edad:{$gte:30}})  
// mayor y menor en rango
db.usuario.find({edad:{$gte:28 ,$lt:30}})  
// nombre en array
db.usuario.find({nombre:{$in:['María García','Juan Pérez']}}) 
// nombre no en array 
db.usuario.find({nombre:{$nin:['María García','Juan Pérez']}})  

// nombres que contengan María o Juan
db.usuario.find({nombre: {$regex: /María|Juan/i}}) 


//compass aplicar filtros de mayor y menor
{age:{$gte:22}}

// encontrar lo de más de 30 y activo true
db.usuario.find(
  {$and:
    [{edad:
        {$gte:30}},
          {activo:true}]}
)

//or, encontrar los que cumplen una condición u otra
db.usuario.find(
  {$or:
    [{edad:
        {$gte:30}},
          {nombre: 'María García'}]}
)

// los que no cumplen ninguna condición, ambas false
db.usuario.find(
  {$nor:
    [{edad:
        {$gte:30}},
          { nombre: 'Carlos López'}]}
)




//modificar age a null en compass

 // actualizar y poner atributo a null
db.usuario.updateOne({ nombre: 'María García'}, { $set: { edad: null } })

// que no son mayores a 30, me da el nulo también
db.usuario.find({edad:{$not:{$gte:30}}}) 

// comprueba los documentos, proporciona información detallada sobre el rendimiento de una consulta
db.usuario.find({nombre: 'María García'}).explain("executionStats") 
// crear índice
db.usuario.createIndex({nombre:1}) 

// solo comprueba una, la que coincide el nombre
db.usuario.find({nombre: 'María García'}).explain("executionStats") 
// ver índices, de inicio, hay uno en el id tambien
db.usuario.getIndexes()  
// eliminar índice
db.usuario.dropIndex("nombre_1")  

// crear índice en compass
// los índices permiten buscar más rápido. Recomendado si muchas búsquedas pero sin actualizar. Actualizar e introducir va lento

// reestablecer edad actualizandola
db.usuario.updateOne({ nombre: 'María García'}, { $set: { edad: 31 } }) 

// entre los nombres seleccionados y con edad más de 30
db.usuario.find(
    {$and:
        [{edad:
            {$gte:30}},
            {nombre:
                {$in:["María García","Juan Pérez"]}
                    }
                    ]})


//condicion or. cumpla que esté en el array de nombres o edad más de 28
db.usuario.find(
    {$or:
        [{edad:
            {$gte:28}},
            {nombre:
                {$in:["María García","Juan Pérez"]}
                    }
                    ]})

// ni nombre en los definidos ni edad superior a 34, no cumple ninguna condición
db.usuario.find(
    {$nor:
        [{edad:
            {$gte:34}},
            {nombre:
                {$in:["María García","Juan Pérez"]}
                    }
                    ]})


// los que no tienen más de 31 de edad mostrando también los null
db.usuario.find({edad:{$not:{$gt:31}}})


// capped limita el tamaño, que se pone en size como máximo y en max, el máximo de documentos
// autoindex para aplicar índice al object id
db.createCollection("companeros",{capped:true,size:1000000,max:100},{autoIndexId:false})

db.createCollection("amigos")
// eliminar colección
db.amigos.drop()  
db.companeros.drop()
// ver colecciones
show collections  




// las aggregations pueden tener varios pasos. Cada paso coge la información del paso anterior
// actualizar ciudad por condición
db.usuario.updateOne({ nombre: "Juan Pérez"}, { $set: { ciudad: "Guadalajara" } })


// filtra mayores de 30, agrupa por la ciudad y suma sus edades
db.usuario.aggregate([
  {
    $match:{edad:{$gte:30}} 
  },
  {
    $group: { _id: "$ciudad", sumaEdad: { $sum: "$edad" } }
  }
])


// muestra valores diferentes en ciudad
db.usuario.aggregate(
    [ { $group : { _id : "$ciudad" } } ]
)


// project define los campos a mostrar, ordena por edad de mayor a menor y limita resultados
db.usuario.aggregate([ 
  { 
    $sort: { "edad": -1 } 
  },
  {
    $project: {
      "nombre": 1,
      "ciudad": 1,
      "edad":1
    }
  },
  {
    $limit: 5
  }
])



// match aplica filtro según condición para cumplir
db.usuario.aggregate([ 
  { $match : { ciudad : "Guadalajara" } },
  { $limit: 2 },
  { $project: {
    "nombre": 1,
    "edad": 1,
    "activo": 1
  }}
])


// primero filtra y después cuenta los de ciudad Guadalajara
db.usuario.aggregate([
  {
    $match: { "ciudad": "Guadalajara" }
  },
  {
    $count: "cuenta"
  }
])

// realiza operación y lo guarda en colección. Agrupa por ciudad
db.usuario.aggregate([
  {
    $group: {
      _id: "$ciudad",
    },
  },
  { $out: "colecAgrup" }
])

// ver resultado
db.colecAgrup.find() 
//eliminar colección
db.colecAgrup.drop() 
show collections


// que contengan Mar
db.usuario.find({ nombre: { $regex: /Mar/ } })


// filtrar los que estén activo, por edad y por ciudad
db.usuario.aggregate([
  {
    $match: {
      activo:true,
      edad: { $gte:30 },
      ciudad: "Guadalajara"
    }
  }
])


// agrupa por ciudad y suma edades
db.usuario.aggregate([
  {
    $group: {
      _id: "$ciudad",
      suma: { $sum: "$edad" }
    }
  }
])



// filtra que sean mayores 30, los agrupa por ciudad y calcula suma de sus edades
db.usuario.aggregate([
  {
    $match: {
      edad: { $gte:30 }
    }
  },
  {
    $group: {
      _id: "$ciudad",
      total: { $sum: "$edad" }
    }
  }
])




// solo mostrar unos campos
db.usuario.aggregate([
  {
    $project: {
      _id: 0, 
      nombre: 1, 
      edad: 1, 
      activo: 1
    }
  }
])

// añadir campos con update
db.usuario.updateOne({ nombre: "Juan Pérez"}, { $set: { edadHijoMayor: 11 } })
db.usuario.updateOne({ nombre: "María García"}, { $set: { edadHijoMayor: 9 } })
db.usuario.updateOne({ nombre: "Carlos López"}, { $set: { edadHijoMayor: 9 } })

// solo mostrar unos campos y hacer cálculo con la diferencia de edades
db.usuario.aggregate([
  {
    $project: {
      nombre: 1,
      edad: 1,
      diferencia: { $subtract: ["$edad", "$edadHijoMayor"] }
    }
  }
])


// contar elementos
db.usuario.countDocuments() 

// cuenta con condición
db.usuario.countDocuments({ edad: { $gte:30 } });

// los que tienen en intereses viajar
db.usuario.find({ intereses: "viajar" }) 


// número de amigos de cada usuario ordenado de mayor a menor
db.usuario.aggregate([
  {
    $project: {
      nombre: 1,
      numero_amigos: { $size: "$amigos" }
    }
  },
  {
    $sort: { numero_amigos: -1 }
  }
])



// media de la edad de los amigos de cada usuario
db.usuario.aggregate([
  {
    $unwind: "$amigos" 
  },
  {
    $group: {
      _id: "$nombre", 
      media_edad_amigos: { $avg: "$amigos.edad" } 
    }
  }
])



// unwind desagrupa los documentos por cada amigo
// crea vaias Marías cada una con un amigo
db.usuario.aggregate([
  {
    $unwind: "$amigos" 
  }
])




// insertar amigo
db.usuario.updateOne(
   { nombre: "Juan Pérez" }, 
   { $push: { amigos: { nombre: "Fede Gonzalez", edad: 25 } } } 
)


// cuánto se ha gastado cada usuario, desagrupa y suma precios
db.usuario.aggregate([
  {
    $unwind: "$historial_compras" 
  },
  {
    $group: {
      _id: "$nombre", 
      total_gastado: { $sum: "$historial_compras.precio" } 
    }
  }
])





// solo mostrar el que más ha gastado
db.usuario.aggregate([
  {
    $unwind: "$historial_compras" 
  },
  {
    $group: {
      _id: "$nombre", 
      total_gastado: { $sum: "$historial_compras.precio" } 
    }
  },
  {
    $sort: { total_gastado: -1 } 
  },
  {
    $limit: 1 
  }
])

// usuarios que tienen de amiga a María
db.usuario.find({ "amigos.nombre": "María García" }, { nombre: 1 }) 

// cuántas compras en total entre todos los usuarios con un precio superior a 250
db.usuario.aggregate([
  {
    $unwind: "$historial_compras" 
  },
  {
    $match: {
      "historial_compras.precio": { $gt: 250 } 
    }
  },
  {
    $count: "total_compras_superior_250" 
  }
])





// busca para Juan en su historial de compras un teléfono. 
// cambia el producto del primer elemento que encuentre
db.usuario.updateOne(
   { nombre: "Juan Pérez", "historial_compras.producto": "Teléfono" }, 
   { $set: { "historial_compras.$.producto": "Teclado" } } 
)

// suma importes compras por producto
db.usuario.aggregate([
  {
    $unwind: "$historial_compras" 
  },
  {
    $group: {
      _id: "$historial_compras.producto", 
      total_gastado: { $sum: "$historial_compras.precio" } 
    }
  }
])



use baseCurso
db.personas.insertMany([
    { nombre: "Juan", edad: 30, ciudad: "Madrid" },
    { nombre: "Ana", edad: 25, ciudad: "Barcelona" },
    { nombre: "Pedro", edad: 35, ciudad: "Valencia" }
])


// imprimir con pretty
db.personas.find().pretty() 

// como array
db.personas.find().toArray() 

// uno a uno
db.personas.find().forEach(doc => printjson(doc)) 

// datos de la base
db.stats() 

// datos de la colección
db.personas.stats() 

// actualizar todos y se les ponen estos deportes
db.personas.updateMany(
    {},  
    {
        $set: {
            deportesFavoritos: ["fútbol", "baloncesto", "tenis"]
        }
    }
)



// eliminar uno del array de deportes para Pedro
db.personas.updateOne(
    { nombre: "Pedro" },
    { $pull: { deportesFavoritos: "baloncesto" } }
)

// añadir uno al array de deportes a Pedro
db.personas.updateOne(
    { nombre: "Pedro" },
    { $push: { deportesFavoritos: "balonmano" } }
)

// ver resultado
db.personas.find({ nombre: "Pedro" }).pretty()

// actualizar y poner un atributo anidado
db.personas.updateOne(
    { nombre: "Pedro" },
    {
        $set: {
            "detalles.personales.contacto.telefono": "123-456-7890"
        }
    }
)


// ver ese atributo
db.personas.find(
    { nombre: "Pedro" },
    { "detalles.personales.contacto.telefono": 1, _id: 0 }
).pretty()


// Insertar elementos, en usuario ponemos un id
db.perfiles.insertMany([
    { usuarioId: ObjectId(), bio: "Bio de Juan", redes: ["twitter.com/juan", "linkedin.com/in/juan"] },
    { usuarioId: ObjectId(), bio: "Bio de Ana", redes: ["twitter.com/ana", "linkedin.com/in/ana"] },
    { usuarioId: ObjectId(), bio: "Bio de Pedro", redes: ["twitter.com/pedro", "linkedin.com/in/pedro"] }
])


// obtener personas y perfiles en unas variables
let personas = db.personas.find().toArray();
let perfiles = db.perfiles.find().toArray();

// ver resultados
personas


// en los perfiles se pone el id del usuario en usuarioId, relación 1 a 1 
personas.forEach((usuario, index) => {
    db.perfiles.updateOne(
        { _id: perfiles[index]._id },
        { $set: { usuarioId: usuario._id } }
    );
});


// relaciones uno a muchos utilizando el nombre
db.posts.insertMany([
    { usuarioNombre: "Juan", titulo: "Post 1 de Juan", contenido: "Contenido del post 1 de Juan" },
    { usuarioNombre: "Juan", titulo: "Post 2 de Juan", contenido: "Contenido del post 2 de Juan" },
    { usuarioNombre: "Ana", titulo: "Post 1 de Ana", contenido: "Contenido del post 1 de Ana" },
    { usuarioNombre: "Pedro", titulo: "Post 1 de Pedro", contenido: "Contenido del post 1 de Pedro" },
    { usuarioNombre: "Pedro", titulo: "Post 2 de Pedro", contenido: "Contenido del post 2 de Pedro" }
])



db.proyectos.insertMany([
    { nombre: "Proyecto 1", descripcion: "Descripción del proyecto 1" },
    { nombre: "Proyecto 2", descripcion: "Descripción del proyecto 2" }
])


// obtener ids solo en variables
let usuarioIds = db.personas.find().toArray().map(user => user._id);
usuarioIds
let proyectoIds = db.proyectos.find().toArray().map(proj => proj._id);

// asociar personas a proyectos con relación muchos a muchos
// en array de proyectos de la persona ponemos los ids
db.personas.updateMany(
    { nombre: "Juan" },
    { $set: { proyectos: [proyectoIds[0], proyectoIds[1]] } }
);

db.personas.updateMany(
    { nombre: "Ana" },
    { $set: { proyectos: [proyectoIds[0]] } }
);

db.personas.updateMany(
    { nombre: "Pedro" },
    { $set: { proyectos: [proyectoIds[1]] } }
);

db.proyectos.updateMany(
    { _id: proyectoIds[0] },
    { $set: { usuarios: [usuarioIds[0], usuarioIds[1]] } }
);

db.proyectos.updateMany(
    { _id: proyectoIds[1] },
    { $set: { usuarios: [usuarioIds[0], usuarioIds[2]] } }
);


// consulta relación uno a uno, buscar perfil de Pedro por su id
db.perfiles.find({ usuarioId: db.personas.findOne({ nombre: "Pedro" })._id }).pretty()

// consulta relación uno a muchos, todos los posts de Juan
db.posts.find({ usuarioNombre: "Juan" }).pretty()


// consulta relación muchos a muchos
db.personas.find({ nombre: "Juan" }, { proyectos: 1, _id: 0 }).pretty()

// relación muchos a muchos mostrar los datos
// filtra de Juan, mira los ids de sus proyectos y los relaciona con la colección de proyectos
db.personas.aggregate([
    { $match: { nombre: "Juan" } },
    {
        $lookup: {
            from: "proyectos",       
            localField: "proyectos", 
            foreignField: "_id",    
            as: "proyectos"         
        }
    },
    {
        $project: {
            _id: 0,
            nombre: 1,
            proyectos: 1
        }
    }
])

// lookup une los campos por la clave
// mira en perfiles, uniendo el usuarioId con id de la persona y lo hace creando varios si tienen varios perfiles
db.personas.aggregate([
    {
        $lookup: {
            from: "perfiles",
            localField: "_id",
            foreignField: "usuarioId",
            as: "perfil"
        }
    },
    {
        $unwind: "$perfil"
    }
]).pretty()


// unir elementos en relación uno a muchos
// mira en posts y el usuarioNombre con el nombre de la persona. Localfield en personas y foreign en posts
db.personas.aggregate([
    {
        $lookup: {
            from: "posts",
            localField: "nombre",
            foreignField: "usuarioNombre",
            as: "posts"
        }
    }
]).pretty()


// unirlo en relación muchos a muchos
// para las personas busca los ids de sus proyectos y los enlaza. Personas tiene campo proyectos y proyecto campo _id
db.personas.aggregate([
    {
        $lookup: {
            from: "proyectos",
            localField: "proyectos",
            foreignField: "_id",
            as: "proyectosDetalles"
        }
    }
]).pretty()


// establecer validaciones al crear elementos
db.createCollection("usuarios", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["nombre", "edad", "ciudad"],
            properties: {
                nombre: {
                    bsonType: "string",
                    description: "debe ser una cadena de texto y es obligatorio"
                },
                edad: {
                    bsonType: "int",
                    minimum: 0,
                    maximum: 120,
                    description: "debe ser un entero en el rango [0, 120] y es obligatorio"
                },
                ciudad: {
                    bsonType: "string",
                    description: "debe ser una cadena de texto y es obligatorio"
                },
                correo: {
                    bsonType: "string",
                    pattern: "^.+@.+$",
                    description: "debe ser una cadena de texto y coincidir con el patrón de correo electrónico"
                }
            }
        }
    }
})


// error en la validación al insertar elemento
db.usuarios.insertMany([
    { _id: ObjectId("64a7b2d5c2e1a4b5c3e1a4b5"), nombre: "Juan", edad: 30, ciudad: "Madrid", correo:"sdaa" },
    { _id: ObjectId("64a7b2d5c2e1a4b5c3e1a4b6"), nombre: "Ana", edad: 25, ciudad: "Barcelona" },
    { _id: ObjectId("64a7b2d5c2e1a4b5c3e1a4b7"), nombre: "Pedro", edad: 35, ciudad: "Valencia" }
])



// editar validación, correo tambien required
// strict rechazará cualquier operación de inserción o actualización que no cumpla con el esquema definido
// moderate aplica las reglas de validación solo a los documentos insertados y a los documentos existentes que se están actualizando
db.runCommand({
    collMod: "usuarios",
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["nombre", "edad", "ciudad", "correo"],
            properties: {
                nombre: {
                    bsonType: "string",
                    description: "debe ser una cadena de texto y es obligatorio"
                },
                edad: {
                    bsonType: "int",
                    minimum: 0,
                    maximum: 120,
                    description: "debe ser un entero en el rango [0, 120] y es obligatorio"
                },
                ciudad: {
                    bsonType: "string",
                    description: "debe ser una cadena de texto y es obligatorio"
                },
                correo: {
                    bsonType: "string",
                    pattern: "^.+@.+$",
                    description: "debe ser una cadena de texto y coincidir con el patrón de correo electrónico y es obligatorio"
                }
            }
        }
    },
    validationLevel: "strict"  
})

// error en la validación
db.usuarios.insertMany([
    { _id: ObjectId("64a7b2d5c2e1a4b5c3e1a4b5"), nombre: "Juan", edad: 130, ciudad: "Madrid" , correo: "chema@gmail.com"}
])


// comandos administrativos con runCommand
// obtener un informe detallado sobre el estado actual del servidor de MongoDB
db.runCommand({ serverStatus: 1 })
// para validar la integridad de los documentos en una colección específica
db.runCommand({ validate: "usuarios" })


// especificar la ruta del directorio donde MongoDB almacena los datos
mongod --dbpath /var/lib/mongodb

// especificar la ruta del archivo donde MongoDB almacenará los registros de log
mongod --logpath /var/log/mongodb/mongod.log

// indicar a MongoDB que debe ejecutarse en segundo plano
mongod --dbpath /var/lib/mongodb --logpath /var/log/mongodb/mongod.log --fork

// writeConcern sirve para especificar el nivel de reconocimiento que debe recibir un cliente al escribir datos en MongoDB. Define cuántos nodos deben confirmar la escritura antes de considerarla exitosa.

// operación de inserción se considerará exitosa solo si la mayoría de los nodos confirman la escritura y se ha confirmado en el journal
db.personas.insertOne(
    { nombre: "Pedro", edad: 35, ciudad: "Valencia" },
    { writeConcern: { w: "majority", j: true } }
)

// w 1 solo el nodo primario, w majority la mayoría, w 0 no se requiere confirmación, w N un número específico
// j true espera que la operación se registre en el journal, false no espera

// iniciar mongo con un archivo de configuracion
mongod -f /etc/mongod.conf


// insertar 
db.personas.insertMany([
    {
        nombre: "Juan",
        edad: 30,
        direccion: {
            calle: "Calle 123",
            ciudad: "Madrid",
            pais: "España"
        },
        telefonos: [
            { tipo: "casa", numero: "123456789" },
            { tipo: "movil", numero: "987654321" }
        ],
        aficiones: ["leer", "fútbol", "programar"]
    },
    {
        nombre: "Ana",
        edad: 25,
        direccion: {
            calle: "Avenida 456",
            ciudad: "Barcelona",
            pais: "España"
        },
        telefonos: [
            { tipo: "casa", numero: "555555555" },
            { tipo: "movil", numero: "444444444" }
        ],
        aficiones: ["pintar", "baloncesto", "música"]
    },
    {
        nombre: "Pedro",
        edad: 35,
        direccion: {
            calle: "Calle 789",
            ciudad: "Valencia",
            pais: "España"
        },
        telefonos: [
            { tipo: "casa", numero: "222222222" },
            { tipo: "movil", numero: "333333333" }
        ],
        aficiones: ["correr", "tenis", "ajedrez"]
    }
])


// ver solo ciudad de la dirección
db.personas.find({}, { "direccion.ciudad": 1, _id: 0 }).pretty()



// solo números de teléfonos móvil
// desagrupo por teléfonos, filtro los móviles y muestro el número
db.personas.aggregate([
    { $unwind: "$telefonos" },
    { $match: { "telefonos.tipo": "movil" } },
    { $project: { _id: 0, nombre: 1, "telefonos.numero": 1 } }
]).pretty()


// personas que tienen en aficiones pintar
db.personas.find({ aficiones: "pintar" }, { nombre: 1, _id: 0 }).pretty()


// campo de la ciudad informado y no nulo
db.personas.find({ "direccion.ciudad": { $exists: true, $ne: null } }).pretty()

// filtrar elementos que el campo sea string
db.personas.find({ "direccion.ciudad": { $type: "string" } }).pretty()


// campo que dice si es adulto, comprueba la edad
db.personas.aggregate([
    {
        $project: {
            nombre: 1,
            edad: 1,
            esAdulto: {
                $cond: { if: { $gte: ["$edad", 18] }, then: true, else: false }
            }
        }
    }
]).pretty()

// si campo no existe, decir desconocido
db.personas.aggregate([
    {
        $project: {
            nombre: 1,
            ciudad: { $ifNull: ["$direccion.ciudad", "Desconocida"] }
        }
    }
]).pretty()


// personas con 3 aficiones
db.personas.find({ aficiones: { $size: 3 } }).pretty()

// personas con estas aficiones concretas
db.personas.find({ aficiones: { $all: ["fútbol", "leer"] } }).pretty()

// buscar que al menos un elemento del array de telefonos tenga eso
// encontrar documentos donde al menos un subdocumento dentro de un array coincide con las condiciones dadas
db.personas.find({ telefonos: { $elemMatch: { tipo: "movil", numero: "987654321" } } }).pretty()

// incorporar el atributo esadulto
db.personas.updateMany(
    { edad: { $gt: 18 } },
    { $set: { esAdulto: true } }
)

// omitir dos primeros al mostrar
db.personas.find().skip(2).pretty()


// primer teléfono de cada persona
db.personas.find({}, { nombre: 1, telefonos: { $slice: 1 }, _id: 0 }).pretty()


// actualizar primer teléfono que sea móvil
db.personas.updateOne(
    { nombre: "Juan", "telefonos.tipo": "movil" },
    { $set: { "telefonos.$.numero": "999999999" } }
)

// incrementar en todos la edad en 1
db.personas.updateMany({}, { $inc: { edad: 1 } })

// actualizar edad de Juan
db.personas.updateOne(
    { nombre: "Juan" }, 
    { $set: { edad: 17 } } 
)

// cambia la edad a 16 porque 17 es mayor
db.personas.updateOne(
    { nombre: "Juan" }, 
    { $min: { edad: 16 } } 
);

// cambia la edad a 30 porque 16 es menor
db.personas.updateOne(
    { nombre: "Juan" },
    { $max: { edad: 30 } }
)

// multiplica edad por 2
db.personas.updateOne(
    { nombre: "Juan" },
    { $mul: { edad: 2 } }
)

// eliminar campo
db.personas.updateOne(
    { nombre: "Juan" },
    { $unset: { ciudad: "" } }
)


// renombrar atributo
db.personas.updateOne(
    { nombre: "Juan" },
    { $rename: { "deportesFavoritos": "hobbies" } }
)



// actualizar primer móvil de Ana
db.personas.updateOne(
    { nombre: "Ana", "telefonos.tipo": "movil" },
    { $set: { "telefonos.$.numero": "555555556" } }
)


// añadir elementos array de hobbies
db.personas.updateOne(
    { nombre: "Juan" },
    { $push: { hobbies: { $each: ["tenis", "natación", "ciclismo"] } } }
)

// eliminar elemento array
db.personas.updateOne(
    { nombre: "Juan" },
    { $pull: { hobbies: "tenis" } }
)


// eliminar último
db.personas.updateOne(
    { nombre: "Juan" },
    { $pop: { hobbies: 1 } }
)


db.createCollection("personas1")

db.personas1.insertMany([
    {
        nombre: "Juan",
        edades: [25, 30, 35],
        telefonos: [
            { tipo: "casa", numero: "123456789" },
            { tipo: "movil", numero: "987654321" }
        ],
        deportes: ["fútbol", "baloncesto"]
    },
    {
        nombre: "Ana",
        edades: [20, 25, 30],
        telefonos: [
            { tipo: "casa", numero: "555555555" },
            { tipo: "movil", numero: "444444444" }
        ],
        deportes: ["pintar", "baloncesto", "música"]
    },
    {
        nombre: "Pedro",
        edades: [30, 35, 40],
        telefonos: [
            { tipo: "casa", numero: "222222222" },
            { tipo: "movil", numero: "333333333" }
        ],
        deportes: ["correr", "tenis", "ajedrez"]
    }
])


// incrementar en 2 la edad de todos
db.personas1.updateMany(
    {},
    { $inc: { "edades.$[]": 2 } }
)

// actualizar el número de teléfono móvil del primer elemento del array telefonos que tenga tipo "movil" para Ana
db.personas1.updateOne(
    { nombre: "Ana" },
    { $set: { "telefonos.$[elem].numero": "555555556" } },
    { arrayFilters: [{ "elem.tipo": "movil" }] }
)

// agrega elemento si no está
db.personas1.updateOne(
    { nombre: "Juan" },
    { $addToSet: { deportes: "natación" } }
)

// analizar consultas
db.personas1.find({ nombre: "Juan" }).explain()


// índice compuesto
db.personas1.createIndex({ nombre: 1, edad: 1 })

// índice en el campo edad solo para los documentos donde edad sea mayor que 25
db.personas1.createIndex(
    { edad: 1 },
    { partialFilterExpression: { edad: { $gt: 25 } } }
)

db.personas1.getIndexes()
// se utiliza el índice edad con partialFilterExpression para optimizar las consultas
db.personas1.find({ edad: { $gt: 25 } }).explain("executionStats")

// agregar campo con fecha actual
db.personas1.updateMany(
    {}, 
    { $set: { fechaExpiracion: new Date() } }
)

// los documentos se eliminarán automáticamente después de 1 hora de su campo fecha de expiración
db.personas1.createIndex(
    { fechaExpiracion: 1 },
    { expireAfterSeconds: 3600 } 
)


// insertar artículos
db.articulos.insertMany([
    {
        titulo: "Cómo optimizar consultas en MongoDB",
        contenido: "Aprende a mejorar el rendimiento de tus consultas...",
        autor: "Ana Gomez",
        etiquetas: ["MongoDB", "Rendimiento", "Consulta"],
        fecha_publicacion: new Date(),
        vistas: 500
    },
    {
        titulo: "Modelado de datos en MongoDB",
        contenido: "Guía para diseñar el esquema de datos en MongoDB...",
        autor: "Pedro Ramirez",
        etiquetas: ["MongoDB", "Esquema", "Diseño"],
        fecha_publicacion: new Date(),
        vistas: 800
    }
])

// crear índice
db.articulos.createIndex({ titulo: "text", contenido: "text" })


// búsqueda de artículos que contienen las palabras "datos"
db.articulos.find({ $text: { $search: "datos" } })

// proyectar los resultados de una búsqueda de texto y obtener metadatos relevantes, como la puntuación de relevancia (textScore).
// se calcula automáticamente un puntaje de relevancia para cada documento que coincide con los términos de búsqueda
db.articulos.find(
    { $text: { $search: "datos" } },
    { score: { $meta: "textScore" } }
)

db.articulos.getIndexes()
// eliminar índice
db.articulos.dropIndex("titulo_text_contenido_text")


// idioma por defecto para las búsquedas de texto y asignar pesos a los campos indexados para controlar la relevancia de los resultados
db.articulos.createIndex(
    { titulo: "text", contenido: "text" },
    {
        default_language: "spanish",
        weights: { titulo: 10, contenido: 5 }
    }
)

db.articulos.find(
    { $text: { $search: "datos" } },
    { score: { $meta: "textScore" } }
)



// localizaciones
// crear índice
db.localizaciones.createIndex({ ubicacion: "2dsphere" })
db.localizaciones.insertMany([
    {
        nombre: "Oficina Central",
        ubicacion: { type: "Point", coordinates: [ -73.9749, 40.7736 ] }  
    },
    {
        nombre: "Tienda A",
        ubicacion: { type: "Point", coordinates: [ -73.9878, 40.7590 ] }
    },
    {
        nombre: "Tienda B",
        ubicacion: { type: "Point", coordinates: [ -73.9804, 40.7621 ] }
    },
    {
        nombre: "Almacén",
        ubicacion: { type: "Point", coordinates: [ -73.9552, 40.7791 ] }
    }
])


// punto de referencia (Longitud, Latitud)
var puntoReferencia = { type: "Point", coordinates: [ -73.9808, 40.7701 ] };

// encontrar ubicaciones cercanas en un radio de 2000 metros
db.localizaciones.find({
    ubicacion: {
        $near: {
            $geometry: puntoReferencia,
            $maxDistance: 2000  
        }
    }
})


// un círculo (Longitud, Latitud, Radio en radianes)
// 0.01 radianes ≈ 0.57 grados ≈ 63 km
var circulo = {
    center: [ -73.9808, 40.7701 ],
    radius: 0.01  
};

// encontrar ubicaciones dentro del círculo
db.localizaciones.find({
    ubicacion: {
        $geoWithin: {
            $centerSphere: [ circulo.center, circulo.radius ]
        }
    }
})


// un polígono como un área de interés (polígono con varios puntos)
var poligono = {
    type: "Polygon",
    coordinates: [
        [
            [ -73.975, 40.775 ],
            [ -73.975, 40.765 ],
            [ -73.965, 40.765 ],
            [ -73.965, 40.775 ],
            [ -73.975, 40.775 ]
        ]
    ]
};

// encontrar ubicaciones que intersecten con el polígono
db.localizaciones.find({
    ubicacion: {
        $geoIntersects: {
            $geometry: poligono
        }
    }
})

// encontrar ubicaciones en un rango de distancia específico
db.localizaciones.find({
    ubicacion: {
        $near: {
            $geometry: puntoReferencia,
            $minDistance: 1000,  
            $maxDistance: 5000  
        }
    }
})


// nsertar personas y actuazliar
db.personas.insertMany([
    { nombre: "Juan" },
    { nombre: "Ana" },
    { nombre: "Pedro" }
])

db.personas.updateOne(
    { nombre: "Juan" },
    { $set: { apellido: "Perez" } }
)

db.personas.updateOne(
    { nombre: "Ana" },
    { $set: { apellido: "Gomez" } }
)

db.personas.updateOne(
    { nombre: "Pedro" },
    { $set: { apellido: "Lopez" } }
)


// concatenar nombre y apellido
db.personas.aggregate([
    {
        $project: {
            nombreCompleto: { $concat: ["$nombre", " ", "$apellido"] }
        }
    }
])


db.productos.insertMany([
    { nombre: "Camiseta", codigo: "ABC12345" },
    { nombre: "Pantalones", codigo: "XYZ67890" }
])


// extraer primeros caracteres
db.productos.aggregate([
    {
        $project: {
            codigoCorto: { $substrCP: ["$codigo", 0, 3] }
        }
    }
])


db.localizaciones.insertMany([
    { nombre: "Oficina Central", coords: "-73.9749,40.7736" },
    { nombre: "Tienda A", coords: "-73.9878,40.7590" }
])


// separa coordenadas por comas y las convierte a double
db.localizaciones.aggregate([
    {
        $project: {
            nombre: 1,
            coordenadas: {
                $map: {
                    input: { $split: ["$coords", ","] },
                    as: "coord",
                    in: { $convert: { input: "$$coord", to: "double" } }
                }
            }
        }
    }
])


db.eventos.insertMany([
    { nombre: "Evento A", fecha: "2024-07-01T00:00:00Z" },
    { nombre: "Evento B", fecha: "2024-07-02T00:00:00Z" }
])

// convertir a fecha
db.eventos.aggregate([
    {
        $project: {
            nombre: 1,
            fecha: { $toDate: "$fecha" }
        }
    }
])

// extrae el año
db.eventos.aggregate([
    {
        $project: {
            nombre: 1,
            fechaISOYear: { $isoWeekYear: { $toDate: "$fecha" } }
        }
    }
])


db.usuariosArray.insertMany([
    { nombre: "Juan", intereses: ["fútbol", "baloncesto", "cine"] },
    { nombre: "Ana", intereses: ["música", "lectura"] }
])


// descompone el array: Ana con música, Ana con lectura
db.usuariosArray.aggregate([
    { $unwind: "$intereses" }
])


db.pedidos.insertMany([
    { cliente: "Juan", productos: ["manzana", "naranja", "manzana"] },
    { cliente: "Ana", productos: ["pera", "pera", "manzana"] }
])


// descompone y agrega elementos a un set eliminando duplicados
db.pedidos.aggregate([
    { $unwind: "$productos" },
    { $group: {
        _id: null, 
        productosUnicos: { $addToSet: "$productos" }
    }},
    { $project: {
        _id: 0,
        productosUnicos: 1
    }}
])


db.usuariosEdades.insertMany([
    { nombre: "Juan", edades: [10, 15, 20, 25] },
    { nombre: "Ana", edades: [30, 35, 40, 45] }
])

// filtra en el array edades mayores de 20
db.usuariosEdades.aggregate([
    {
        $project: {
            nombre: 1,
            edadesMayoresDe20: {
                $filter: {
                    input: "$edades",
                    as: "edad",
                    cond: { $gt: ["$$edad", 20] }
                }
            }
        }
    }
])

// primer elemento del array
db.pedidos.aggregate([
    {
        $project: {
            cliente: 1,
            primerProducto: { $first: "$productos" }
        }
    }
])

// insertar con isodate
db.ventas.insertMany([
    { producto: "Producto A", cantidad: 5, fecha: ISODate("2024-01-01T00:00:00Z") },
    { producto: "Producto B", cantidad: 15, fecha: ISODate("2024-02-01T00:00:00Z") },
    { producto: "Producto C", cantidad: 25, fecha: ISODate("2024-03-01T00:00:00Z") },
    { producto: "Producto D", cantidad: 35, fecha: ISODate("2024-04-01T00:00:00Z") }
])


// agrupa las ventas en intervalos de 10 unidades
db.ventas.aggregate([
    {
        $bucket: {
            groupBy: "$cantidad",
            boundaries: [0, 10, 20, 30, 40],
            default: "Otros",
            output: {
                totalVentas: { $sum: 1 },
                productos: { $push: "$producto" }
            }
        }
    }
])


db.empleados.insertMany([
    { nombre: "Juan", salario: 3000, fecha_contratacion: ISODate("2020-01-01T00:00:00Z") },
    { nombre: "Ana", salario: 4000, fecha_contratacion: ISODate("2019-01-01T00:00:00Z") },
    { nombre: "Pedro", salario: 5000, fecha_contratacion: ISODate("2018-01-01T00:00:00Z") }
])


// escribe los resultados en una nueva colección mutliplicando los salarios por 12
db.empleados.aggregate([
    {
        $project: {
            nombre: 1,
            salarioAnual: { $multiply: ["$salario", 12] }
        }
    },
    {
        $out: "empleadosResumen"
    }
])


const puntoReferencia = { type: "Point", coordinates: [ -73.96, 40.76 ] };


// ubicaciones cercanas al punto de referencia, en un radio de 5000m
db.localizaciones.aggregate([
    {
        $geoNear: {
            near: puntoReferencia,
            distanceField: "distancia",
            spherical: true,
            maxDistance: 5000 
        }
    }
]).pretty()

// estadísticas de la colección
db.localizaciones.stats()


db.productosInc.insertMany([
    { nombre: "Producto A", amount: 10, valuation: 100 },
    { nombre: "Producto B", amount: 20, valuation: 200 },
    { nombre: "Producto C", amount: 30, valuation: 300 }
])

// incrementar a la vez dos campos
db.productosInc.updateMany(
    {},
    { $inc: { amount: 10, valuation: 100 } }
)

// crear usuario
db.createUser({
    user: "adminUser",
    pwd: "adminPassword",
    roles: [
        { role: "userAdminAnyDatabase", db: "admin" },
        { role: "readWriteAnyDatabase", db: "admin" }
    ]
})


// autenticarse
db.auth("adminUser", "adminPassword")


mongo -u adminUser -p adminPassword --authenticationDatabase admin


// para una base concreta
db.createUser({
    user: "dbUser",
    pwd: "dbPassword",
    roles: [
        { role: "readWrite", db: "baseCurso" }
    ]
})


// actualizar usuario
db.updateUser("dbUser", {
    pwd: "newDbPassword",
    roles: [
        { role: "readWrite", db: "baseCurso" },
        { role: "dbAdmin", db: "baseCurso" }
    ]
})

mongo -u dbUser -p dbPassword --authenticationDatabase baseCurso


// importar datos
mongoimport --host localhost --db miBaseDeDatos --collection productos --type csv --file productos.csv --headerline


// cursor
const cursor = db.productos.find({  }); 

while (cursor.hasNext()) {
    const producto = cursor.next();
    print(`Nombre: ${producto.nombre}, codigo: ${producto.codigo}`);
}


mongoimport --db baseDatos --collection persons --file persons.json --jsonArray
use baseDatos
show collections

// busca mujeres, agrupa por estado y cuenta
db.persons.aggregate([
    { $match: { gender: 'female' } },
    { $group: { _id: { state: "$location.state" }, totalPersons: { $sum: 1 } } },
    { $sort: { totalPersons: -1 } }
]).pretty();



// crea el nombre completo poniendo primera letra a mayúscula
// substrCP coge el resto de la cadena hasta el final
db.persons.aggregate([
    {
      $project: {
        _id: 0,
        gender: 1,
        fullName: {
          $concat: [
            { $toUpper: { $substrCP: ['$name.first', 0, 1] } },
            {
              $substrCP: [
                '$name.first',
                1,
                { $subtract: [{ $strLenCP: '$name.first' }, 1] }
              ]
            },
            ' ',
            { $toUpper: { $substrCP: ['$name.last', 0, 1] } },
            {
              $substrCP: [
                '$name.last',
                1,
                { $subtract: [{ $strLenCP: '$name.last' }, 1] }
              ]
            }
          ]
        }
      }
    }
  ]).pretty();




// convertir tipos de datos (birthdate a tipo date, location.coordinates a tipo double), y calcular age
// nombre completo como antes  
  db.persons.aggregate([
    {
      $project: {
        _id: 0,
        name: 1,
        email: 1,
        birthdate: { $convert: { input: '$dob.date', to: 'date' } },
        age: "$dob.age",
        location: {
          type: 'Point',
          coordinates: [
            {
              $convert: {
                input: '$location.coordinates.longitude',
                to: 'double',
                onError: 0.0,
                onNull: 0.0
              }
            },
            {
              $convert: {
                input: '$location.coordinates.latitude',
                to: 'double',
                onError: 0.0,
                onNull: 0.0
              }
            }
          ]
        }
      }
    },
    {
      $project: {
        gender: 1,
        email: 1,
        location: 1,
        birthdate: 1,
        age: 1,
        fullName: {
          $concat: [
            { $toUpper: { $substrCP: ['$name.first', 0, 1] } },
            {
              $substrCP: [
                '$name.first',
                1,
                { $subtract: [{ $strLenCP: '$name.first' }, 1] }
              ]
            },
            ' ',
            { $toUpper: { $substrCP: ['$name.last', 0, 1] } },
            {
              $substrCP: [
                '$name.last',
                1,
                { $subtract: [{ $strLenCP: '$name.last' }, 1] }
              ]
            }
          ]
        }
      }
    }
  ]).pretty();



// agrupa y ordena por año de nacimiento
  db.persons.aggregate([
    {
      $project: {
        _id: 0,
        name: 1,
        email: 1,
        birthdate: { $toDate: '$dob.date' },
        age: "$dob.age",
        location: {
          type: 'Point',
          coordinates: [
            {
              $convert: {
                input: '$location.coordinates.longitude',
                to: 'double',
                onError: 0.0,
                onNull: 0.0
              }
            },
            {
              $convert: {
                input: '$location.coordinates.latitude',
                to: 'double',
                onError: 0.0,
                onNull: 0.0
              }
            }
          ]
        }
      }
    },
    {
      $project: {
        gender: 1,
        email: 1,
        location: 1,
        birthdate: 1,
        age: 1,
        fullName: {
          $concat: [
            { $toUpper: { $substrCP: ['$name.first', 0, 1] } },
            {
              $substrCP: [
                '$name.first',
                1,
                { $subtract: [{ $strLenCP: '$name.first' }, 1] }
              ]
            },
            ' ',
            { $toUpper: { $substrCP: ['$name.last', 0, 1] } },
            {
              $substrCP: [
                '$name.last',
                1,
                { $subtract: [{ $strLenCP: '$name.last' }, 1] }
              ]
            }
          ]
        }
      }
    },
    { $group: { _id: { birthYear: { $isoWeekYear: "$birthdate" } }, numPersons: { $sum: 1 } } },
    { $sort: { numPersons: -1 } }
  ]).pretty();



 // crear colección con validaciones 
  db.createCollection('posts1', {
    validator: {
      $jsonSchema: {
        bsonType: 'object',
        required: ['title', 'text', 'creator', 'comments'],
        properties: {
          title: {
            bsonType: 'string',
            description: 'must be a string and is required'
          },
          text: {
            bsonType: 'string',
            description: 'must be a string and is required'
          },
          creator: {
            bsonType: 'objectId',
            description: 'must be an objectid and is required'
          },
          comments: {
            bsonType: 'array',
            description: 'must be an array and is required',
            items: {
              bsonType: 'object',
              required: ['text', 'author'],
              properties: {
                text: {
                  bsonType: 'string',
                  description: 'must be a string and is required'
                },
                author: {
                  bsonType: 'objectId',
                  description: 'must be an objectid and is required'
                }
              }
            }
          }
        }
      }
    }
  });
  


// cambiar validaciones
  db.runCommand({
    collMod: 'posts1',
    validator: {
      $jsonSchema: {
        bsonType: 'object',
        required: ['title', 'text', 'creator', 'comments'],
        properties: {
          title: {
            bsonType: 'string',
            description: 'must be a string and is required'
          },
          text: {
            bsonType: 'string',
            description: 'must be a string and is required'
          },
          creator: {
            bsonType: 'objectId',
            description: 'must be an objectid and is required'
          },
          comments: {
            bsonType: 'array',
            description: 'must be an array and is required',
            items: {
              bsonType: 'object',
              required: ['text', 'author'],
              properties: {
                text: {
                  bsonType: 'string',
                  description: 'must be a string and is required'
                },
                author: {
                  bsonType: 'objectId',
                  description: 'must be an objectid and is required'
                }
              }
            }
          }
        }
      }
    },
    validationAction: 'warn'
  });
  
// warn permite que los documentos que no cumplen con las reglas de validación sean aceptados, pero advierte sobre estas violaciones
// error si un documento no cumple con las reglas de validación, rechazará la operación de inserción o actualización y lanzará un error.


// cuenta agrupando por buckets y muestra su media de edad y el número de personas
db.persons.aggregate([
  {
    $bucket: {
      groupBy: '$dob.age',
      boundaries: [18, 30, 40, 50, 60, 120],
      output: {
        numPersons: { $sum: 1 },
        averageAge: { $avg: '$dob.age' }
      }
    }
  }
]).pretty();


// otra forma, pero marcando 5 buckets
db.persons.aggregate([
    {
      $bucketAuto: {
        groupBy: '$dob.age',
        buckets: 5,
        output: {
          numPersons: { $sum: 1 },
          averageAge: { $avg: '$dob.age' }
        }
      }
    }
  ]).pretty();

// hombres, concatenando nombre completo con la fecha de nacimiento, ordenando por esa fecha y saltanto 10 y limitando
  db.persons.aggregate([
    { $match: { gender: "male" } },
    { $project: { _id: 0, gender: 1, name: { $concat: ["$name.first", " ", "$name.last"] }, birthdate: { $toDate: "$dob.date" } } },
    { $sort: { birthdate: 1 } },
    { $skip: 10 },
    { $limit: 10 }
  ]).pretty();


// guardando resultados en otra colección
  db.persons.aggregate([
    {
      $project: {
        _id: 0,
        name: 1,
        email: 1,
        birthdate: { $toDate: '$dob.date' },
        age: "$dob.age",
        location: {
          type: 'Point',
          coordinates: [
            {
              $convert: {
                input: '$location.coordinates.longitude',
                to: 'double',
                onError: 0.0,
                onNull: 0.0
              }
            },
            {
              $convert: {
                input: '$location.coordinates.latitude',
                to: 'double',
                onError: 0.0,
                onNull: 0.0
              }
            }
          ]
        }
      }
    },
    {
      $project: {
        gender: 1,
        email: 1,
        location: 1,
        birthdate: 1,
        age: 1,
        fullName: {
          $concat: [
            { $toUpper: { $substrCP: ['$name.first', 0, 1] } },
            {
              $substrCP: [
                '$name.first',
                1,
                { $subtract: [{ $strLenCP: '$name.first' }, 1] }
              ]
            },
            ' ',
            { $toUpper: { $substrCP: ['$name.last', 0, 1] } },
            {
              $substrCP: [
                '$name.last',
                1,
                { $subtract: [{ $strLenCP: '$name.last' }, 1] }
              ]
            }
          ]
        }
      }
    },
    { $out: "transformedPersons" }
  ]).pretty();


db.transformedPersons.createIndex({ location: "2dsphere" });
  

// documentos cercanos a un punto y filtrando por edad
db.transformedPersons.aggregate([
  {
    $geoNear: {
      near: {
        type: 'Point',
        coordinates: [-18.4, -42.8]
      },
      maxDistance: 1000000,
      query: { age: { $gt: 30 } },
      distanceField: "distance"
    }
  },
  { 
    $limit: 10 
  }
]).pretty();




db.friends.insertMany([
  {
    name: "Alice",
    age: 25,
    hobbies: ["reading", "cycling", "hiking"],
    examScores: [85, 90, 78]
  },
  {
    name: "Bob",
    age: 30,
    hobbies: ["cooking", "swimming"],
    examScores: [88, 92, 80]
  },
  {
    name: "Charlie",
    age: 22,
    hobbies: ["gaming", "programming", "chess"],
    examScores: [95, 87, 89]
  },
  {
    name: "Diana",
    age: 28,
    hobbies: ["painting", "dancing"],
    examScores: [91, 85, 88]
  }
]);


// agrupa hobbies por edad, para tal edad, hay estos hobbies
  db.friends.aggregate([
    { $unwind: "$hobbies" }, 
    { $group: { _id: { age: "$age" }, allHobbies: { $push: "$hobbies" } } }
  ]).pretty();


// ahora sin repetir
db.friends.aggregate([
    { $unwind: "$hobbies" }, 
    { $group: { _id: { age: "$age" }, allHobbies: { $addToSet: "$hobbies" } } }
  ]).pretty();


// coge el elemento 2 solo. Parte del 2 y solo coge 1
db.friends.aggregate([
    { $project: { _id: 0, examScore: { $slice: ["$examScores", 2, 1] } } }
  ]).pretty();


// muestra tamaño del array
  db.friends.aggregate([
    { $project: { _id: 0, numScores: { $size: "$examScores" } } }
  ]).pretty();



// filtra para cada array, cada uno los scores mayores a 90
db.friends.aggregate([
  {
    $project: {
      _id: 0, 
      name: 1, 
      highScores: {
        $filter: {
          input: "$examScores",
          as: "score",
          cond: { $gt: ["$$score", 90] }
        }
      }
    }
  }
]).pretty();


// mayor score de cada uno
  db.friends.aggregate([
    { $unwind: "$examScores" },
    { $project: { _id: 1, name: 1, age: 1, score: "$examScores" } },
    { $sort: { score: -1 } },
    { $group: { _id: "$_id", name: { $first: "$name" }, maxScore: { $max: "$score" } } },
    { $sort: { maxScore: -1 } }
  ]).pretty();